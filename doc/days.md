# 日程
## day1

### 事件1 ch0：构建基础环境
使用NixOS配置了原子级环境并创建了SPHINX文档

使用qemu启动了基础的OS并运行了HELLO WORLD用户态程序
### 事件2 ch0: 用户态程序
从_start开始编写了一个main.rs 并学习了链接器脚本，实现了Write trait，panic_handler

了解了ELF程序的内存布局，分段；使用rust内联汇编；如何使用链接器脚本来更改内存布局 以及清理bss

学习了如何在内核态与M态进行交互


## day2
### 事件1 ch1: 批处理环境
了解了批处理在计算机中的运用 以及批处理的内存布局

## 第一次会议

### 进展
1.基础设施构建:  使用Nix的flake特性 制作了一个高度可还原的原子性的环境 来减少复现所需的时间
2. 文档自动化: 使用sphinx制作了一个文档网页 以方便查询文档
3.内核原型开发（Chapter 1）：

底层掌控： 深入剖析 RISC-V 权限架构（U/S/M 模式）与 SBI 调用规范；通过 Rust global_asm! 与自定义 Linker Script 精确操纵 ELF 内存布局。

裸机环境搭建： 脱离标准库（no_std），实现了基于串口的 Write Trait 抽象及基础系统调用，成功构建了具备自引导能力的极简 Rust 裸机执行环境。
### 困难
多维知识耦合的挑战:  
在 Ch1 的实践中，最大的挑战并非逻辑实现，而是如何处理极高密度的底层陌生概念。由于需要从零构建执行环境，我面临着从 RISC-V 汇编、SBI 规范到链接器（Linker Script）语法的全方位认知门槛。
由于软硬件交互的紧耦合特性，学习过程被迫呈现“广度优先”状态。为了实现一个简单的字符打印，必须同时打通指令集、寄存器状态、特权级切换以及内存段对齐等多个知识盲区。
### 新的想法
新设想：构建“底层技术依赖图谱”，实现从 广度优先向深度优先学习 的跨越
针对内核学习初期认知负载过重的问题，我计划构建一套声明式的知识依赖图谱。
痛点分析： 底层开发（如 RISC-V 裸机编程）具有极高的知识耦合度。传统的“广度优先”学习（BFS）容易导致认知碎片化，在面对汇编、SBI、Linker Script 等交织概念时产生迷茫。

解决方案： 借鉴 Gentoo 包管理器的依赖解析逻辑，在 Sphinx 文档中集成知识树。

核心逻辑： 当引入一个新概念（如 ecall）时，自动关联其前置依赖（如特权级切换原理、寄存器传参规范）与后置应用（如系统调用实现）。

预期目标： 将被动的信息查询转变为主动的启发式深度遍历（Heuristic DFS），使每一次技术攻坚都能追根溯源，构建起从底层指令到高层抽象的确定性认知链路。
### 后续的学习
循序渐进的系统构建： 紧随 rCore 路线图，计划在 ch2（地址空间管理）与 ch3（多道程序与分时多任务）的学习中，持续深化对 RISC-V 硬件特性的掌控。
AI 辅助的“启发式驱动”： 利用 AI 助手作为实时语义解析器，辅助拆解复杂的内联汇编与特权级转换逻辑
声明式文档与动态图谱： 在 Sphinx 环境中实时同步实验笔记，同步构建**“底层技术依赖图谱”**。将零散的 no_std 知识点（如页表优化、上下文切换损耗控制）转化为结构化的知识树，实现从单一章节实验到全局架构思维的跃迁。
## 2-12
### 事件1
根据容易出现的困惑与困难 添加了`AI助手困难点与知识链条分析` 板块 以预测可能出现的困难与对应的解答.

同时为每个`可查阅`的高密度知识构建文档 让AI助手进行指向。 以明晰图的结构。

### 事件2
为了快速的了解每一章的内容 从ch2开始 我添加了 `TL;DR` 策略。 将整个章节进行快速的总结与提炼。

#### 结果
经过我的实验 在快速学习新的章节时速度有了明显的提升

### 事件3
完成了ch1与ch2 阅读并理解了ch1与ch2的源代码 了解了特权级隔离 Trap机制 二进制封装 编写了riscv rust等
### 事件4
驱动模式重构：从“知识驱动”转向“源码驱动”（事件 4）
哲学变更： 彻底打破“文档定义代码”的传统模式。我认为任何脱离源码的 OS 文档都是一个黑盒，唯有实现细节是透明的。

优化方案： 采用**代码驱动型（Code-Driven）**讲解模式。从项目的具体结构入手 具体的 Rust asm! 汇编宏或寄存器操作入手，逆向推导并引入相关的体系结构理论，确保每一行代码的背后都有坚实的物理语义支撑。
## 2-13
### 事件1
添加了每个章节的跨越过程

通过对比各章节间的**架构跨越**，直观展现内核从微型组件到复杂系统的**演进过程**，并深入解析功能变更背后的技术驱动力及其在系统设计中的必要性。
### 事件2
完成了 ch3的编程题 简答题 

通过了ch3的测试

### 事件3
我觉得可以直接从做作业入手 
## 2-14
### 事件1
我发现在接触专业名词时会困惑 所以在**章节的开头**引入了专业名词的解释。

这样的好处是在章节的开头就能对技术有个大概的印象



### 总结1
我发现在学习的过程中 顺序对学习效率起决定性作用。

如果在一开始就从代码开始 那么就能对底层的操作有更好的实践理解

如果在一开始就使用TLDR 那么就能对整章从上到下的有把控

如果引入每一章的对比 那么可以串起完整的操作系统进化链条

如果在一开始就对每个专业名词进行解释 那么在阅读时会有印象 以达到更好的效果和效率
### 事件2
完成了ch5 ch6
