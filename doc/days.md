# 日程
## day1

### 事件1 ch0：构建基础环境
使用NixOS配置了原子级环境并创建了SPHINX文档

使用qemu启动了基础的OS并运行了HELLO WORLD用户态程序
### 事件2 ch0: 用户态程序
从_start开始编写了一个main.rs 并学习了链接器脚本，实现了Write trait，panic_handler

了解了ELF程序的内存布局，分段；使用rust内联汇编；如何使用链接器脚本来更改内存布局 以及清理bss

学习了如何在内核态与M态进行交互


## day2
### 事件1 ch1: 批处理环境
了解了批处理在计算机中的运用 以及批处理的内存布局

## 第一次会议

### 进展
1.基础设施构建:  使用Nix的flake特性 制作了一个高度可还原的原子性的环境 来减少复现所需的时间
2. 文档自动化: 使用sphinx制作了一个文档网页 以方便查询文档
3.内核原型开发（Chapter 1）：

底层掌控： 深入剖析 RISC-V 权限架构（U/S/M 模式）与 SBI 调用规范；通过 Rust global_asm! 与自定义 Linker Script 精确操纵 ELF 内存布局。

裸机环境搭建： 脱离标准库（no_std），实现了基于串口的 Write Trait 抽象及基础系统调用，成功构建了具备自引导能力的极简 Rust 裸机执行环境。
### 困难
多维知识耦合的挑战:  
在 Ch1 的实践中，最大的挑战并非逻辑实现，而是如何处理极高密度的底层陌生概念。由于需要从零构建执行环境，我面临着从 RISC-V 汇编、SBI 规范到链接器（Linker Script）语法的全方位认知门槛。
由于软硬件交互的紧耦合特性，学习过程被迫呈现“广度优先”状态。为了实现一个简单的字符打印，必须同时打通指令集、寄存器状态、特权级切换以及内存段对齐等多个知识盲区。
### 新的想法
新设想：构建“底层技术依赖图谱”，实现从 广度优先向深度优先学习 的跨越
针对内核学习初期认知负载过重的问题，我计划构建一套声明式的知识依赖图谱。
痛点分析： 底层开发（如 RISC-V 裸机编程）具有极高的知识耦合度。传统的“广度优先”学习（BFS）容易导致认知碎片化，在面对汇编、SBI、Linker Script 等交织概念时产生迷茫。

解决方案： 借鉴 Gentoo 包管理器的依赖解析逻辑，在 Sphinx 文档中集成知识树。

核心逻辑： 当引入一个新概念（如 ecall）时，自动关联其前置依赖（如特权级切换原理、寄存器传参规范）与后置应用（如系统调用实现）。

预期目标： 将被动的信息查询转变为主动的启发式深度遍历（Heuristic DFS），使每一次技术攻坚都能追根溯源，构建起从底层指令到高层抽象的确定性认知链路。
### 后续的学习
循序渐进的系统构建： 紧随 rCore 路线图，计划在 ch2（地址空间管理）与 ch3（多道程序与分时多任务）的学习中，持续深化对 RISC-V 硬件特性的掌控。
AI 辅助的“启发式驱动”： 利用 AI 助手作为实时语义解析器，辅助拆解复杂的内联汇编与特权级转换逻辑
声明式文档与动态图谱： 在 Sphinx 环境中实时同步实验笔记，同步构建**“底层技术依赖图谱”**。将零散的 no_std 知识点（如页表优化、上下文切换损耗控制）转化为结构化的知识树，实现从单一章节实验到全局架构思维的跃迁。
## 2-12
### 事件1
根据容易出现的困惑与困难 添加了`AI助手困难点与知识链条分析` 板块 以预测可能出现的困难与对应的解答.

同时为每个`可查阅`的高密度知识构建文档 让AI助手进行指向。 以明晰图的结构。

### 事件2
为了快速的了解每一章的内容 从ch2开始 我添加了 `TL;DR` 策略。 将整个章节进行快速的总结与提炼。

#### 结果
经过我的实验 在快速学习新的章节时速度有了明显的提升
