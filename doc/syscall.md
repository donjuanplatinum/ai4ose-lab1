# 系统调用 (System Call)

## 1. 什么是系统调用

系统调用是操作系统为用户态进程提供的一套标准接口，允许进程请求内核代为执行某些受限操作（如 I/O 访问、进程管理、内存映射等）。

* **特权级隔离**：在 RISC-V 中，用户态运行在 **U-Mode (User)**，内核运行在 **S-Mode (Supervisor)**。系统调用是跨越 U 到 S 模式的唯一合法“大门”。
* **ABI 约束**：系统调用必须遵循特定的调用约定（Calling Convention），通过寄存器传递参数，而非传统的栈传递。

---

## 2. 系统调用在 RISC-V 的执行过程

在 RISC-V 架构下，系统调用的触发与返回依赖于 `ecall` 和 `sret` 指令。

### 2.1 执行流简述
1.  **参数准备**：用户态将系统调用号放入 `a7` 寄存器，参数放入 `a0-a5`。
2.  **触发异常**：执行 `ecall` 指令，硬件自动完成以下动作：
    * 将当前 PC 存入 `sepc`。
    * 将特权级提升至 S-Mode。
    * 跳转到 `stvec` 指令的异常处理入口。
3.  **内核处理**：
    * **上下文保存**：内核在栈（或 `sscratch` 指向的 `TrapContext`）中保存所有通用寄存器。
    * **分发处理**：根据 `a7` 的值跳转到对应的内核处理函数。
4.  **状态恢复与返回**：
    * 将返回值写入 `a0`。
    * 恢复寄存器上下文。
    * 执行 `sret`，硬件恢复 `sepc` 到 PC，并将特权级降回 U-Mode。

### 2.2 性能挑战 (Kernel Engineer Perspective)
* **TLB Flush**：如果切换上下文导致地址空间变化（如切换页表），会引发巨大的 TLB 刷新开销。
* **Cache Pollution**：从 U 切换到 S 会破坏 L1 Cache 的局部性。
* **Context Switch**：保存/恢复 32 个 64 位寄存器是纯粹的 CPU 周期浪费。在 `nostd` 优化中，通常会尝试使用 `sscratch` 预留一段快速保存区。



---

## 3. 常见的系统调用

以下是符合 `POSIX` 或 `rCore` 实验标准的常见系统调用：

| 分类 | 调用名 | ID (a7) | 功能简述 |
| :--- | :--- | :--- | :--- |
| **文件操作** | `read` | 63 | 从文件描述符读取数据到缓冲区 |
| | `write` | 64 | 将缓冲区数据写入文件描述符 |
| | `open` | 56 | 打开文件并返回文件描述符 |
| **进程管理** | `exit` | 93 | 终止当前进程并返回退出码 |
| | `fork` | 220 | 创建当前进程的副本（父子进程） |
| | `exec` | 221 | 替换当前进程的映像为新程序 |
| **内存管理** | `sbrk` / `brk` | 214 | 调整堆空间大小 |
| | `mmap` | 222 | 将文件或设备映射到内存地址空间 |
| **其他** | `getpid` | 172 | 获取当前进程的 PID |
| | `yield` | 124 | 主动让出 CPU 使用权 |

---

## 4. 硬核优化方向 (Engineering Focus)

作为 Rust 内核工程师，在实现这些系统调用时，你可以关注：

* **Zero-Copy**：在 `read`/`write` 时，通过内核页表映射直接访问用户态缓冲区，避免 `memcpy`。
* **Syscall Batching**：减少 `ecall` 频率。参考 Linux 的 `io_uring` 思想，在 `nostd` 环境下通过共享内存环形缓冲区同步数据。
* **Inline Assembly**：在用户态封装库（如 `user_lib`）中，使用 `asm!` 宏精确控制寄存器分配，减少不必要的入栈操作。
