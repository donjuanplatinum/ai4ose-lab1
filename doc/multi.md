# 多道程序与分时系统
## ch2-ch3的系统演进

 rCore 演进：Chapter 2 -> Chapter 3 (特权级隔离至分时多任务)

### 1. 核心维度对比

| 维度 | Chapter 2 (Batch System) | Chapter 3 (Multi-tasking) | 演进意义 |
| :--- | :--- | :--- | :--- |
| **内存布局** | 内存中仅存在一个 App | **多个 App 同时驻留内存** | 消除 App 加载时的磁盘/IO 等待时延 |
| **任务切换** | `TrapContext` (U <-> S) | **`TaskContext` (S <-> S)** | 实现内核控制流之间的平滑切换 |
| **调度触发** | App 主动退出或崩溃 | **计时器中断 (Preemption)** | 剥夺 App 的“永久占据权”，实现公平调度 |
| **栈空间** | 单个内核栈 | **每个任务拥有独立内核栈** | 支持任务状态的持久化存储与切换 |

---

### 2. 关键机制演进

#### A. 引入 TaskContext (任务上下文)
在 Ch2 中，我们只需处理特权级切换。在 Ch3 中，由于要实现“切走 A 任务，换上 B 任务”，必须保存内核态的执行状态。



```rust
// src/task/context.rs
#[repr(C)]
pub struct TaskContext {
    ra: usize,    // 返回地址（切换后从哪开始跑）
    sp: usize,    // 内核栈指针
    s: [usize; 12], // Callee-saved registers (s0-s11)
}
```

## 多道程序
核心定义：内存中同时存放多个独立的程序，当一个程序因为 I/O 等原因无法继续运行时，CPU 立即切换到另一个程序执行。

工程目的：极大化 CPU 利用率。

底层行为：

内存驻留：不同于 Ch2 加载一个跑一个，Ch3 预先将所有 App 加载到内存的不同位置。

被动切换：只有当当前程序“停下来”（比如等待输入或主动 yield）时，内核才接管。

硬核痛点：由于多个程序都在内存里，必须通过 link_section 配合链接脚本，为每个程序分配不同的起始地址（在 Ch4 引入页表之前，这是物理隔离的唯一手段）。

## 分时系统
核心定义：在多道程序的基础上，引入**时间片（Time Slot）**概念。内核通过硬件时钟中断，强行剥夺当前程序的执行权，循环调度每一个程序。

工程目的：最小化 响应时间（Response Time），实现“伪并行”。

底层行为：

抢占（Preemption）：内核不再等 App 主动让位，而是依靠硬件计时器（Timer Interupt）。

快速切换：通过极其精简的汇编指令（如 rCore 中的 __switch.S）保存和恢复上下文。

硬核痛点：高频率的切换会带来 Context Switch Overhead。作为追求极致优化的工程师，你会关注切换时寄存器压栈的数量以及 L1 Cache 的刷新开销。
