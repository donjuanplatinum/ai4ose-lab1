# rCore-Tutorial (Ch1-Ch8) 极客版学习规划：2-12 至 2-16

## 📅 2-12：基础与特权级 (Ch1 - Ch2)

* **Ch1 裸机控制**：`nostd` 打印、SBI 栈帧、`entry.S`。
* **Ch2 批处理**：**Trap 机制**、特权级切换（U ↔ S）。
* **🛠️ 硬核指标**：理解链接脚本如何将 App 序列化进内核镜像。
* **💡 思考**：在 `__alltraps` 中，寄存器压栈的顺序是否会影响 CPU 写缓冲（Write Buffer）的效率？

## 📅 2-13：多任务与虚存 (Ch3 - Ch4)

* **Ch3 分时任务**：任务上下文切换 (`__switch`)、协作式与抢占式调度。
* **Ch4 地址空间**：**SV39 三级页表**、虚拟内存管理。
* **🛠️ 硬核指标**：实现物理页帧分配器，理解 `satp` 切换。
* **💡 思考**：频繁切换页表会导致 TLB 刷新，在 Rust 中如何利用 `Unsafe` 绕过不必要的开销？

## 📅 2-14：进程与文件系统 (Ch5 - Ch6)

* **Ch5 进程管理**：`fork`、`exec`、进程树、僵尸进程。
* **Ch6 文件系统 (EasyFS)**：**重点！** 索引节点 (Inode)、磁盘块管理、位图。
* **🛠️ 硬核指标**：手写一个块设备驱动层（基于内存或简单 VirtIO）。
* **💡 思考**：**缓冲区优化**。EasyFS 读写块时如何做 Cache？在高负载下，如何减少 `read/write` 的系统调用次数？

## 📅 2-15：IPC 与并发 (Ch7 - Ch8)

* **Ch7 进程间通信**：管道 (Pipe)、信号 (Signal)。
* **Ch8 并发机制**：内核线程 (Thread)、锁 (Mutex/Semaphore)、死锁。
* **🛠️ 硬核指标**：实现线程创建与同步原语。
* **💡 思考**：**锁优化**。在内核态下，Spinlock（自旋锁）和 Mutex（睡眠锁）对 CPU 缓存一致性的影响有什么区别？如何实现一个无锁队列？

## 📅 2-16：全局优化与综合实验

* **综合目标**：打通 `User Shell` -> `Pipe` -> `Fork` -> `Exec` -> `File IO`。
* **复盘任务**：
* [ ] 完成 Ch1-Ch8 所有实验练习（Lab 1-5）。
* [ ] 构建知识树：从 `_start` 上电到内核处理第一个线程死锁。
* [ ] **Gentoo 精神**：尝试开启编译优化 `opt-level = 3`，并分析二进制文件大小对指令缓存（I-Cache）的影响。


# rCore Ch1-Ch8 知识图谱与费曼挑战

## Ch1-Ch2：裸机、引导与特权级

* **核心知识点**：
* SBI 调用接口（ecall 机制）。
* 链接脚本（Linker Script）的 `Memory Layout` 布局。
* 特权级切换（Trap 上下文保存与恢复）。
* 控制流：`S模式` 调度 `U模式` 的逻辑。


* **费曼提问（请解释给我听）**：
1. 当 CPU 执行到内核的第一条指令时，`sp`（栈指针）和 `pc`（程序计数器）的状态是如何由链接脚本和 SBI 共同确定的？
2. 为什么在处理 Trap 时，必须先在汇编中手动保存寄存器，而不是直接跳转到 Rust 函数？
3. 描述一下：一个 App 从执行 `ecall` 开始，到内核处理完返回 App，这中间硬件寄存器发生了哪些“物理变化”？



---

## Ch3-Ch4：多任务与虚存管理

* **核心知识点**：
* 任务上下文切换（`__switch` 与 `TaskContext`）。
* 时钟中断与抢占式调度。
* SV39 三级页表：虚拟地址到物理地址的转换。
* 页帧分配器（Frame Allocator）。


* **费曼提问（请解释给我听）**：
1. `TaskContext` 切换和 `TrapContext` 切换有什么本质区别？为什么一个在 Rust 里做，一个必须在汇编里做？
2. 如果我在页表中没有开启 `U` 位（User 标志），App 访问自己的虚拟地址会发生什么？
3. 开启页表（设置 `satp` 寄存器）的那一瞬间，为什么内核代码不会因为地址突然改变而崩掉？



---

## Ch5-Ch6：进程管理与文件系统

* **核心知识点**：
* 进程控制块（PCB）与地址空间克隆。
* `fork`/`exec`/`waitpid` 的内核实现。
* EasyFS 磁盘布局：超级块、位图、Inode、数据块。
* 块设备驱动（BlockDevice Trait）。


* **费曼提问（请解释给我听）**：
1. `fork` 时，子进程的返回值是如何被修改成 0 的？请从寄存器的角度说明。
2. 如果我要在 `nostd` 环境下优化文件系统性能，为什么“块缓存（Block Cache）”是第一优先级？
3. 描述一下：从内核加载一个 ELF 文件到最后跳转到进程入口，内存中发生了哪些搬运和映射操作？



---

## Ch7-Ch8：IPC 与并发

* **核心知识点**：
* 管道（Pipe）的环形缓冲区与阻塞机制。
* 信号（Signal）的异步处理流程。
* 内核线程（Thread）与进程的资源共享关系。
* 互斥锁（Mutex）与信号量（Semaphore）的实现。


* **费曼提问（请解释给我听）**：
1. 当一个进程读一个空的管道被挂起时，它是如何被“踢出”调度队列并在数据到达后被“唤醒”的？
2. 在多核/多线程环境下，为什么简单的 `count += 1` 会出问题？内核是如何利用硬件原子指令实现 `Mutex` 的？
3. 信号（Signal）处理函数是在用户栈运行还是内核栈运行？如果是用户栈，内核是如何强迫进程去执行它的？




