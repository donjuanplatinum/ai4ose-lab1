# rCore-Tutorial (Ch1-Ch5) 硬核学习规划：2-12 至 2-16
📅 2-12：从零开始的裸机控制 (Ch1 & Ch2)
> 核心目标：理解硬件上电后的第一行代码，建立内核特权级边界。
> 
 * Ch1：环境搭建与裸机 Hello World
   * [ ] 配置 riscv64gc-unknown-none-elf 目标平台。
   * [ ] 编写 linker.ld：显式指定 .text.entry 位于 0x80200000。
   * [ ] 实现 panic_handler 与基于 SBI 的 console_putchar。
 * Ch2：特权级切换与批处理系统
   * [ ] 重点：编写汇编代码保存/恢复 TrapContext。
   * [ ] 难点：理解 sstatus、sepc、stvec 寄存器在 U -> S 切换中的作用。
 * 🧠 底层硬核思考：
   * 为什么 entry.S 中的栈空间必须对齐？（提示：CPU 缓存行与内存访问效率）。
   * 对比 ecall 指令和普通 jal 指令在流水线和特权级检查上的本质区别。
📅 2-13：多任务与协作式调度 (Ch3)
> 核心目标：脱离单任务模型，实现最初级的“并发”。
> 
 * Ch3：多道程序与分时多任务
   * [ ] 实现 TaskContext 切换逻辑（重点在汇编 __switch）。
   * [ ] 引入定时器中断：通过 sie 寄存器和 SBI 设置时间片。
   * [ ] 区分 Trap 上下文 与 任务上下文 的存放位置与作用时机。
 * 🧠 底层硬核思考：
   * 系统调用优化：频繁的 sys_yield 会导致多少次上下文切换开销？
   * 缓存命中：任务切换后，旧任务留在 Cache 里的数据如何影响新任务的冷启动延迟？
📅 2-14：地址空间——虚存管理的艺术 (Ch4)
> 核心目标：攻克 OS 最硬核的模块之一：分页机制。
> 
 * Ch4：地址空间与 SV39 页表
   * [ ] 实现页帧管理器 FrameAllocator（掌握 页优化 的基础）。
   * [ ] 构建三级页表结构，实现虚拟地址到物理地址的转换。
   * [ ] 重难点：内核切换到虚拟地址模式（开启 satp）后的“平滑过渡”。
 * 🧠 底层硬核思考：
   * TLB 优化：在切换 satp 时，如何最小化 sfence.vma 带来的流水线刷新代价？
   * 大页（Huge Page）思考：在 nostd 中，如何设计内存布局以支持 2MB 或 1GB 大页来减少 TLB Miss？
📅 2-15：进程管理与系统调用 (Ch5)
> 核心目标：实现现代操作系统的核心抽象——进程。
> 
 * Ch5：进程管理
   * [ ] 实现 fork()：深度拷贝地址空间。
   * [ ] 实现 exec()：从 ELF 文件重新加载应用并初始化用户栈。
   * [ ] 建立进程树结构，实现 waitpid() 清理僵尸进程。
 * 🧠 底层硬核思考：
   * 缓冲区优化：在 exec 读取 ELF 时，如何利用预读和缓冲区减少物理磁盘（或内存模拟磁盘）的 IO 次数？
   * Copy-on-Write (CoW)：构思如何通过页表项的标志位实现零拷贝的进程创建。
📅 2-16：全局复盘与知识依赖树构建
> 核心目标：将前五章打通，形成闭环。
> 
 * 全流程走读：从 _start -> SBI -> Kernel -> Trap -> Shell -> Fork -> App 的完整生命周期。
 * 实验测试：
   * [ ] 完成 Ch5 课后实验：实现 spawn 或者是 priority 调度。
   * [ ] Gentoo 式极致优化：尝试手动调整编译选项（如 LTO），观察生成的二进制文件布局变化。
 * AI 测评总结：
   * 要求 AI 对你进行一次“内核深度面试”，涵盖从系统调用开销到页表转换的各种边界情况。

