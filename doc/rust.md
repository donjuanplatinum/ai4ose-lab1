# Rust 系统编程硬核知识点：编译器布局标记

在 `no_std` 内核开发与底层工程优化中，这些属性控制着符号的可见性、链接行为以及在二进制文件中的物理布局。

---

## 编译器标记 (Compiler Attributes)

### 1. `#[used]`
- **核心作用**：强制编译器在生成的对象文件（Object File）中保留该符号。
- **底层原理**：防止 LLVM 的 **Dead Code Elimination (DCE)** 优化将未被显式引用的静态变量剔除。
- **内核场景**：
    - **中断向量表**：硬件直接跳转，代码中无引用，不加 `#[used]` 会被编译器“优化”掉。
    - **内核版本签名**：在二进制特定位置埋入元数据，供外部工具（如 `readelf`）识别。
- **注意**：它保证符号留在 `.o` 文件，但链接器仍可能通过 `--gc-sections` 将其删除（配合 `link_section` 可解）。

### 2. `#[no_mangle]`
- **核心作用**：禁用 Rust 的名称重整（Name Mangling）机制。
- **底层原理**：使导出的符号名与源码中的函数名/变量名完全一致（按照 C 风格导出）。
- **内核场景**：
    - **链接脚本匹配**：在 `linker.ld` 中通过名字引用函数（如 `KEEP(*(_start))`）。
    - **汇编交互**：在 `.S` 汇编文件中通过 `call _start` 直接跳转。
    - **系统调用入口**：确保内核入口符号在符号表中是唯一且可预测的。

### 3. `#[link_section = "..."]`
- **核心作用**：将符号强制放置到二进制文件的特定**段（Section）**中。
- **底层原理**：干预 LLVM 的代码生成，不使用默认的 `.text`、`.data` 或 `.bss`。
- **内核场景**：
    - **`.text.entry`**：确保内核启动代码位于镜像的最前端。
    - **页表对齐优化**：将高频使用的指令段放在单独的 Section，在链接脚本中通过 `ALIGN(4K)` 强制对齐，降低 **TLB Miss**。
    - **DMA 缓冲区**：将特定变量放入非缓冲（Non-cacheable）内存段，规避 CPU 缓存一致性问题。

### 4. `#[export_name = "..."]`
- **核心作用**：在不改变 Rust 源码函数名的前提下，指定其在目标文件中的导出名称。
- **底层原理**：类似于 `#[no_mangle]`，但更具灵活性。它直接定义了符号表中的字符串键。
- **内核场景**：
    - **版本兼容性**：Rust 内部函数名可以随架构变化（如 `init_v1`），但对外统一导出为 `kernel_init`。
    - **强符号覆盖**：在多模块链接时，显式指定导出名称以覆盖弱符号（Weak Symbols）。

---

## 硬核组合技：构建内核入口

```rust
// 典型的内核启动点配置
#[no_mangle]                               // 链接器可见
#[used]                                    // 防止 DCE 剔除
#[link_section = ".text.entry"]           // 配合链接脚本实现物理位置置顶
pub extern "C" fn _start() -> ! {
    // 强制 16 字节对齐（取决于架构需求）
    unsafe { core::arch::asm!(".align 4"); }
    loop {}
}
```
