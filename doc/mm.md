# 虚拟内存
## TLDR
Ch4 通过三级页表机制实现了硬件级的地址隔离，让每个应用都以为自己拥有整块从 0x10000 开始的连续内存，而内核则通过“跳板页”在不破坏流水线的情况下完成虚实地址空间的丝滑切换。

## 名词解释
- SV39: RISC-V的一种分页模式 使用39位的虚拟地址空间
- MMU: 内存管理单元 **翻译** VA为PA
- VA/PA: 虚拟地址/物理地址
- TLB: 旁路转换缓冲（快表）,作为页表项的**缓存**以加速**地址翻译**的过程
- SATP: RISC-V控制分页算法的**寄存器**
- VPN: 虚拟页号 VA被划分为VPN[2],VPN[1],VPN[0]
- PPN: 物理页号 页表项中存储的实际指向物理内存的编号
- PTE: 页表项 指向页面 存储PPN以及RWXVU标志位
- PageFault: 缺页异常
- 页面: 内存管理的最小**原子单位**
- VP： 虚拟页面 VA的高位
- PPF： 物理页帧 PA的高位
- PT： 页表 PTE的集合 指向各个页面
- Offset： 业内偏移 在
## ch3-ch4的演进
从 Ch3 到 Ch4，本质上是操作系统从**“物理内存管理器”**向**“虚拟地址空间映射器”**的跃迁。

如果用一句话来形容这个演进：**内核从“地勤搬运工”变成了“时空幻术师”。**

硬件层面： 配置了`satp`寄存器 以让RISCV从**直接寻址**->**多级页表寻址**

软件层面： 引入了`MemorySet`(一个进程完整的地址空间,包含进程的页表 和该进程拥有的虚拟内存区域)和`MapArea`(定义了内存段的rust抽象.text .data等)
### 核心演进维度对比

| 维度 | Chapter 3 (物理隔离/分时) | Chapter 4 (虚拟存储/分页) | 演进意义 |
| --- | --- | --- | --- |
| **地址视图** | **PA == VA** (应用感知物理地址) | **VA != PA** (每个应用独占  空间) | 彻底解决了应用链接时的地址冲突。 |
| **隔离手段** | 靠自觉 (或者基址寄存器限长) | **MMU + 页表权限位 (U/R/W/X)** | 硬件级强制隔离，应用无法触碰内核或其他应用。 |
| **内存分配** | **静态槽位** (连续的大块物理内存) | **动态分页** (离散的  物理页帧) | 极大提高了内存利用率，支持按需分配。 |
| **Trap 机制** | 直接跳入内核地址 | **Trampoline (跳板)** 切换地址空间 | 解决了开启分页后，页表切换导致的“指令连续性”断裂。 |

---

### 1. 编译与加载：从“定制”到“通用的 ELF”

* **Ch3**：为了避免物理内存重叠，每个应用在编译时必须通过脚本指定不同的基地址（`0x80400000`, `0x80420000`...）。
* **Ch4**：所有应用都链接到 `0x10000`。内核不再简单地“拷贝”二进制流，而是解析 **ELF 文件的 Program Header**，根据段（Segment）的要求，按需创建映射。

### 2. 管理模型：从“任务控制块”到“地址空间结构”

Ch4 引入了极其关键的抽象层级：

* **`PageTable`**: 维护 SV39 三级页表。
* **`MapArea`**: 描述一段逻辑连续的区域（如 .text 或 .stack）。
* **`MemorySet`**: 整个地址空间的集合。

> **演进点**：`TaskControlBlock` 内部不再只是存上下文，而是持有一个 `MemorySet`。切换任务等同于切换 `satp` 寄存器。

### 3. Trap 处理的范式转移

这是 Ch4 最硬核的改变：

* 在 Ch3 中，发生 Trap 时直接换个栈指针就开始运行内核代码。
* 在 Ch4 中，应用页表里根本没有内核代码映射。**如果不切页表，跳进内核就等于跳进虚无（Page Fault）；如果切了页表，当前指令的下一条就找不到了。**
* **解决方案**：在所有页表的最高处（）强行插入一个映射完全相同的 **Trampoline**。它像一个中转站，让 CPU 在切换 `satp`（世界观转换）的过程中，指令流依然连续。

---

### 4. 接口层面的阵痛：读写用户数据

由于内核和应用不在一个“维度”（地址空间），内核再也不能直接解引用应用传来的指针了。

* **Ch3**: `let val = *(ptr as *const u8);` (直接读)
* **Ch4**: `PageTable::translate(ptr)` (手动查表，模拟 MMU)

> 这就是你刚才重写 `sys_get_time` 时感到麻烦的原因——你必须手动游走多级页表，才能找到数据在物理内存里的真身。

---

### 总结：为什么要演进？

为了**“确定性”**。
在 Ch3 中，开发者得盯着物理内存布局防止写超；在 Ch4 中，不管底层物理内存多碎，应用看到的永远是整齐划一的虚拟空间。这为 Ch5 引入 `fork`、`exec` 以及更复杂的进程管理奠定了基础。

---
```
======================= 逻辑视图 (Virtual Memory) =======================

      Application A (satp_A)               Application B (satp_B)
    +-----------------------+            +-----------------------+
Max |   Trampoline (共享)    |            |   Trampoline (共享)    | <--- 这里的物理页是同一块
    +-----------------------+            +-----------------------+
    |   TrapContext (独占)   |            |   TrapContext (独占)   | <--- 这里的物理页是不同的
    +-----------------------+            +-----------------------+
    |           ...         |            |           ...         |
    +-----------------------+            +-----------------------+
    |      User Stack       |            |      User Stack       |
    +-----------------------+            +-----------------------+
    |      App Data/Text    |            |      App Data/Text    |
0x1k+-----------------------+            +-----------------------+ <--- 大家都觉得自己从 0x10000 开始

======================= 物理视图 (Physical Memory) ======================

Address      Content                    Description
-------------------------------------------------------------------------
0x80000000  +-----------------------+
            |   OpenSBI / RustSBI   |  M-Mode Firmware
0x80020000  +-----------------------+
            |      Kernel .text     |  包含 strampoline 代码
            +-----------------------+
            |      Kernel .data     |  包含 App Binaries (作为数据源)
            +-----------------------+
            |      Kernel .bss      |  内核全局变量
            +-----------------------+
            |  Dynamic Page Frames  | <--- 核心区域：物理页帧管理器管理
            |  (Frame Allocator)    |
            |                       |
            |  +-----------------+  |  被 App A 的页表映射
            |  |  App A Pages    |  |  
            |  +-----------------+  |
            |  +-----------------+  |  被 App B 的页表映射
            |  |  App B Pages    |  |
            |  +-----------------+  |
            |  +-----------------+  |  被内核页表映射
            |  |  Kernel Stacks  |  |  (Ch4 后内核栈也改为动态分配)
            |  +-----------------+  |
-------------------------------------------------------------------------
```

## 地址空间

### 分页机制
由硬件（MMU）驱动、软件（内核）维护的“内存虚拟化”协议。

#### 流程
```
User Program (VA Space)    |           Hardware / MMU (SV39 Logic)
      (Execution Context)      |         (Hardware State Machine Walk)
-------------------------------|----------------------------------------------------
                               |
 [1] CPU 执行访存指令            |
     ld a0, 0(t0)              |
     (t0 = Virtual Address)    |
               |               |
 [2] MMU 拦截请求 --------------> [3] 硬件/TLB 快速查找
               |               |      - 查找 TLB (Translation Lookaside Buffer)
               |               |      - [命中?] -> 直接跳转到 [7] 拼接物理地址
               |               |      - [未命中] -> 进入 [4] 开始 Page Walk
                               |                |
                               | [4] 根页表查询 (VPN[2])
                               |      - 从 satp 寄存器获取根页表基址 (PPN)
                               |      - 索引 = VA[38:30], 访问物理内存读取 PTE1
                               |      - 检查 PTE1.V (有效位), PTE1.R/W/X (是否为叶)
                               |                |
                               | [5] 二级页表查询 (VPN[1])
                               |      - 从 PTE1 获取二级页表基址
                               |      - 索引 = VA[29:21], 访问物理内存读取 PTE2
                               |      - 检查权限与有效位
                               |                |
                               | [6] 三级页表查询 (VPN[0])
                               |      - 从 PTE2 获取三级页表基址
                               |      - 索引 = VA[20:12], 访问物理内存读取 PTE3
                               |      - 检查 PTE3.V, 确认 R/W/X 权限位
                               |                |
                               | [7] 物理地址拼接 (Physical Address)
                               |      - PA = (PTE3.PPN << 12) | VA[11:0] (Offset)
                               |      - 更新 TLB 记录
                               |                |
 [9] 指令完成 (读取数据) <------- [8] 访问物理内存 (Bus Transaction)
     a0 = [PA] 的内容           |      - 将 PA 发送到内存总线
                               |      - 如果权限检查失败 -> 触发 Page Fault 异常
-------------------------------|----------------------------------------------------
```

这里采用的是**SV39多级页表算法**


#### 组成
有**多级页表** 其中 一级页表存放指向二级页表的**指针** 以此类推。 页表里面存放 **PTE（页表项）** 指向**页面** 
### satp寄存器
satp寄存器就是用来 **内存管理与地址转换** 的CSR 存放了**一级根页表** 和**TLB**
```
63      60 59                  44 43                                     0
 +----------+----------------------+----------------------------------------+
 |   MODE   |         ASID         |                  PPN                   |
 | (4 bits) |      (16 bits)       |               (44 bits)                |
 +----------+----------------------+----------------------------------------+
      |                |                              |
      |                |              [Physical Page Number]
      |                |              根页表（一级页表）的物理页号
      |                |              物理地址 = PPN * 4096 (Page Size)
      |                |
      |          [Address Space Identifier]
      |          地址空间标识符。用于区分不同进程的 TLB 缓存，
      |          避免每次切换 satp 都必须完全刷新 TLB (sfence.vma)。
      |          在 rCore Ch4 早期实现中通常填 0。
      |
 [Address Translation Mode]
 0000 -> Bare (无分页，VA = PA)
 1000 -> SV39 (3级页表，39位虚拟地址)
 1001 -> SV48 (4级页表，48位虚拟地址)
```


### 虚拟地址
SV39的虚拟地址布局

```
虚拟地址 (Virtual Address)
+------------+------------+------------+---------------+
| VPN[2] (9b)| VPN[1] (9b)| VPN[0] (9b)| Offset (12b)  |
+-----+------+-----+------+-----+------+-------+-------+
      |            |            |              |
      |      +-----+      +-----+              |
      |      |            |                    |
      v      v            v                    | (直接拷贝)
   [L2表] -> [L1表] -> [L0表(叶子)]            |
                           |                   |
                           v                   v
+--------------------------+-------------------+-------+
|                PPN (44 bits)                 | Offset|
+----------------------------------------------+-------+
物理地址 (Physical Address, 56-bit)
```
### 页表项
```
页表项 (Page Table Entry - SV39)
+-------------+----------------------------------------------+------------+---+---+---+---+---+---+---+---+
| Reserved    |              PPN (物理页号)                   |    RSW     | D | A | G | U | X | W | R | V |
+-------------+----------------------------------------------+------------+---+---+---+---+---+---+---+---+
|  [63:54]    |                 [53:10]                      |   [9:8]    | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
|   (10b)     |                  (44b)                       |    (2b)    |   |   |   |   |   |   |   |   |
+-------------+----------------------------------------------+------------+---+---+---+---+---+---+---+---+
      |                            |                               |        |   |   |   |   |   |   |   |
      v                            v                               v        |   |   |   |   |   |   |   +-- 有效位 (Valid)
   保留位                     指向物理页帧                      内核保留位   |   |   |   |   |   |   +------ 读 (Read)
 (必须为0)                    (Physical Page)                  (Software)   |   |   |   |   |   +---------- 写 (Write)
                                                                            |   |   |   |   +-------------- 执行 (Execute)
                                                                            |   |   |   +------------------ 用户态 (User)
                                                                            |   |   +---------------------- 全局 (Global)
                                                                            |   +-------------------------- 访问 (Accessed)
                                                                            +------------------------------ 脏页 (Dirty)
```
	
### 物理页帧管理器
如果说MMU用于**翻译** 那么物理页帧管理器负责**初始化**和**分配** 页表项

## 代码实现
有了 刚才的抽象 我们可以立马的进行代码阅读

### os/src/mm/address.rs
首先是抽象

注意 地址 = 页号(高44)+偏移(低12)
```rust
/// 物理地址PA
#[derive(Copy, Clone, Ord, PartialOrd, Eq, PartialEq)]
pub struct PhysAddr(pub usize);
/// 虚拟地址VA
#[derive(Copy, Clone, Ord, PartialOrd, Eq, PartialEq)]
pub struct VirtAddr(pub usize);
/// 物理页号PPN
#[derive(Copy, Clone, Ord, PartialOrd, Eq, PartialEq)]
pub struct PhysPageNum(pub usize);
/// 虚拟页号PPN
#[derive(Copy, Clone, Ord, PartialOrd, Eq, PartialEq)]
pub struct VirtPageNum(pub usize);

```
