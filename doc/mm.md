# 虚拟内存
## TLDR
Ch4 通过三级页表机制实现了硬件级的地址隔离，让每个应用都以为自己拥有整块从 0x10000 开始的连续内存，而内核则通过“跳板页”在不破坏流水线的情况下完成虚实地址空间的丝滑切换。

## ch3-ch4的演进
从 Ch3 到 Ch4，本质上是操作系统从**“物理内存管理器”**向**“虚拟地址空间映射器”**的跃迁。

如果用一句话来形容这个演进：**内核从“地勤搬运工”变成了“时空幻术师”。**


### 核心演进维度对比

| 维度 | Chapter 3 (物理隔离/分时) | Chapter 4 (虚拟存储/分页) | 演进意义 |
| --- | --- | --- | --- |
| **地址视图** | **PA == VA** (应用感知物理地址) | **VA != PA** (每个应用独占  空间) | 彻底解决了应用链接时的地址冲突。 |
| **隔离手段** | 靠自觉 (或者基址寄存器限长) | **MMU + 页表权限位 (U/R/W/X)** | 硬件级强制隔离，应用无法触碰内核或其他应用。 |
| **内存分配** | **静态槽位** (连续的大块物理内存) | **动态分页** (离散的  物理页帧) | 极大提高了内存利用率，支持按需分配。 |
| **Trap 机制** | 直接跳入内核地址 | **Trampoline (跳板)** 切换地址空间 | 解决了开启分页后，页表切换导致的“指令连续性”断裂。 |

---

### 1. 编译与加载：从“定制”到“通用的 ELF”

* **Ch3**：为了避免物理内存重叠，每个应用在编译时必须通过脚本指定不同的基地址（`0x80400000`, `0x80420000`...）。
* **Ch4**：所有应用都链接到 `0x10000`。内核不再简单地“拷贝”二进制流，而是解析 **ELF 文件的 Program Header**，根据段（Segment）的要求，按需创建映射。

### 2. 管理模型：从“任务控制块”到“地址空间结构”

Ch4 引入了极其关键的抽象层级：

* **`PageTable`**: 维护 SV39 三级页表。
* **`MapArea`**: 描述一段逻辑连续的区域（如 .text 或 .stack）。
* **`MemorySet`**: 整个地址空间的集合。

> **演进点**：`TaskControlBlock` 内部不再只是存上下文，而是持有一个 `MemorySet`。切换任务等同于切换 `satp` 寄存器。

### 3. Trap 处理的范式转移

这是 Ch4 最硬核的改变：

* 在 Ch3 中，发生 Trap 时直接换个栈指针就开始运行内核代码。
* 在 Ch4 中，应用页表里根本没有内核代码映射。**如果不切页表，跳进内核就等于跳进虚无（Page Fault）；如果切了页表，当前指令的下一条就找不到了。**
* **解决方案**：在所有页表的最高处（）强行插入一个映射完全相同的 **Trampoline**。它像一个中转站，让 CPU 在切换 `satp`（世界观转换）的过程中，指令流依然连续。

---

### 4. 接口层面的阵痛：读写用户数据

由于内核和应用不在一个“维度”（地址空间），内核再也不能直接解引用应用传来的指针了。

* **Ch3**: `let val = *(ptr as *const u8);` (直接读)
* **Ch4**: `PageTable::translate(ptr)` (手动查表，模拟 MMU)

> 这就是你刚才重写 `sys_get_time` 时感到麻烦的原因——你必须手动游走多级页表，才能找到数据在物理内存里的真身。

---

### 总结：为什么要演进？

为了**“确定性”**。
在 Ch3 中，开发者得盯着物理内存布局防止写超；在 Ch4 中，不管底层物理内存多碎，应用看到的永远是整齐划一的虚拟空间。这为 Ch5 引入 `fork`、`exec` 以及更复杂的进程管理奠定了基础。

---
```
======================= 逻辑视图 (Virtual Memory) =======================

      Application A (satp_A)               Application B (satp_B)
    +-----------------------+            +-----------------------+
Max |   Trampoline (共享)    |            |   Trampoline (共享)    | <--- 这里的物理页是同一块
    +-----------------------+            +-----------------------+
    |   TrapContext (独占)   |            |   TrapContext (独占)   | <--- 这里的物理页是不同的
    +-----------------------+            +-----------------------+
    |           ...         |            |           ...         |
    +-----------------------+            +-----------------------+
    |      User Stack       |            |      User Stack       |
    +-----------------------+            +-----------------------+
    |      App Data/Text    |            |      App Data/Text    |
0x1k+-----------------------+            +-----------------------+ <--- 大家都觉得自己从 0x10000 开始

======================= 物理视图 (Physical Memory) ======================

Address      Content                    Description
-------------------------------------------------------------------------
0x80000000  +-----------------------+
            |   OpenSBI / RustSBI   |  M-Mode Firmware
0x80020000  +-----------------------+
            |      Kernel .text     |  包含 strampoline 代码
            +-----------------------+
            |      Kernel .data     |  包含 App Binaries (作为数据源)
            +-----------------------+
            |      Kernel .bss      |  内核全局变量
            +-----------------------+
            |  Dynamic Page Frames  | <--- 核心区域：物理页帧管理器管理
            |  (Frame Allocator)    |
            |                       |
            |  +-----------------+  |  被 App A 的页表映射
            |  |  App A Pages    |  |  
            |  +-----------------+  |
            |  +-----------------+  |  被 App B 的页表映射
            |  |  App B Pages    |  |
            |  +-----------------+  |
            |  +-----------------+  |  被内核页表映射
            |  |  Kernel Stacks  |  |  (Ch4 后内核栈也改为动态分配)
            |  +-----------------+  |
-------------------------------------------------------------------------
```
## 
## mm
```
虚拟地址 (Virtual Address)
+---------------------------+---------------+
|       VPN (27 bits)       | Offset (12b)  |
+-----------+---------------+-------+-------+
            |                       |
      [ MMU 查表 ]                  | (直接透传)
            |                       |
            v                       v
+-----------------------------------+-------+
|           PPN (44 bits)           | Offset|
+-----------------------------------+-------+
物理地址 (Physical Address, 56-bit)
```
